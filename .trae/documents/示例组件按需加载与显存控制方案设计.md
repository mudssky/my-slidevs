## 背景与目标
- 目标：所有 three.js 示例组件仅在进入视口时加载与运行，离开后立即释放资源与停止动画，避免累计占用显存与内存。
- 约束：沿用 Vue 3 + Slidev，优先复用现有工作区能力，不引入重量级新依赖。

## 现状分析
- 渲染循环：组件在 `onMounted` 启动 RAF（例：`projects/slidevs/learn-threejs/components/GeometryShowcase.vue:68` 的 `requestAnimationFrame(animate)`），在 `onUnmounted` 以布尔标志停止循环。
- 可见性：已有基于 `IntersectionObserver` 的 GUI 显隐封装，但 three.js 核心资源未统一 `.dispose()`；Renderer/材质/纹理/几何体的释放不一致。
- 使用方式：示例组件直接在 Markdown/页面中以标签渲染，Slide 切换会卸载，但同一页上的多个示例可能同时常驻。

## 方案选项
- 方案 A：组件级按需挂载（强烈推荐）
  - 进入视口通过 `IntersectionObserver`/`useElementVisibility` 切换 `v-if` → 首次进入时 `defineAsyncComponent` 动态导入并挂载；离开视口时卸载组件，触发统一清理。
  - 优点：最小侵入、适用于所有示例、按视口严格控制生命周期。
  - 风险：频繁进入/离开视口的抖动需节流与延迟卸载。
- 方案 B：页面级虚拟化 + Slidev 分页粒度控制
  - 将长页拆分为多页，保证单页只包含 1–2 个示例；配合 Slidev 的路由卸载特性，即离开页面即销毁。
  - 优点：实现简单、无额外逻辑；
  - 风险：内容组织需调整，交互连贯性略受影响。
- 方案 C：渲染器复用池（高级）
  - 在同一页上复用单一 `WebGLRenderer` 与共享 `PMREMGenerator`，示例之间切换 Scene/Camera；离开视口时释放当前场景资源但保留 Renderer 以避免频繁上下文创建。
  - 优点：降低多上下文的显存占用与创建开销；
  - 风险：耦合度高、对各示例的独立性有影响，不建议作为默认方案。
- 方案 D：统一资源追踪与销毁（横切增强）
  - 提供通用清理工具：遍历 Scene/材质/纹理/几何体/后期管线/控制器/动画混合器并调用 `.dispose()`；清理 `THREE.Cache`、停止 RAF、断开观察者。
  - 优点：与 A/B/C 组合使用，形成标准释放流程；
  - 风险：需在各示例接入一次性清理接口。

## 推荐方案
- 主方案：A + D 组合。
  - 进入视口时才动态导入并挂载示例；离开视口后立即卸载并执行统一清理清单。
  - 配置合理的节流与延迟（如 150–300ms）避免滚动中的频繁抖动。
- 次方案：B 作为结构性优化（对极长页）。

## 实施步骤
1. 新增通用封装 `LazyThreeDemo`（包装任意示例组件）：
   - 属性：`loader: () => Promise<Component>`（动态导入函数）；可选 `preload=false`、`exitDelay=200`。
   - 行为：
     - 进入视口：按需 `await loader()` → 挂载 → 触发示例 `start()`；
     - 离开视口：等待 `exitDelay` → 卸载 → 调用示例暴露的 `dispose()` 并停止 RAF。
   - 输出插槽：占位骨架/加载中 UI。
2. 新增组合式工具 `useThreeDemoLifecycle()`：
   - 提供 `start()`/`stop()` 与资源登记 `track(...)`，统一实现：
     - 停止动画：保存 `rafId`、在 `stop()` 取消并置标志；
     - 资源释放：遍历 Scene/几何/材质/纹理/纹理管线/控制器/动画混合器等执行 `.dispose()`；`renderer.dispose()`、`THREE.Cache.clear()`；
     - 断开所有观察者与事件监听器。
   - 组件接入：各示例在 `onMounted` 使用 `track()` 注册创建的资源对象，在 `onUnmounted` 或外部 `dispose()` 调用清理。
3. 在 Markdown/页面中用 `LazyThreeDemo` 包装现有示例：
   - 示例：`<LazyThreeDemo :loader="() => import('./components/GLTFLoadAndAnimate.vue')" />`。
   - 视口外不加载；滚动进入才加载；离开释放显存。
4. 微调示例组件：
   - 将现有 `onUnmounted` 的停止逻辑迁移到 `dispose()` 并通过 `useThreeDemoLifecycle` 统一实现。
   - 补全未释放的资源：`renderer`、`pmrem`、`composer`、`passes`、`geometries`、`materials`、`textures`、`controls`、`mixer`。
5. 运行参数优化（可选）：
   - `powerPreference: 'low-power'`、`antialias: false`、限制 `setPixelRatio(Math.min(devicePixelRatio, 1.5))`、降低 `samples`/后期分辨率。

## 资源释放清单
- 渲染器：`renderer.dispose()`；必要时 `renderer.forceContextLoss()`。
- 场景对象：`scene.traverse` 收集 `Mesh` → `geometry.dispose()`；`material`（含 `uniforms` 纹理）执行 `dispose()`。
- 纹理与立方体贴图：`texture.dispose()`、`envMap.dispose()`、`cubeTarget.dispose()`；`PMREMGenerator.dispose()`。
- 加载器缓存：`THREE.Cache.clear()`。
- 控件/后期：`controls.dispose()`、`composer.reset(); composer.passes = []; composer.renderer = null` 并释放各 `Pass`（如有 `dispose()`）。
- 动画：`mixer.stopAllAction()`，如实现支持 `mixer.uncacheRoot(object)`。
- 事件/观察者：取消 `requestAnimationFrame`、`removeEventListener`、`ResizeObserver.disconnect()`、`IntersectionObserver.disconnect()`。

## 验证方法
- 在同一页布置多个示例，滚动测试：进入视口触发加载与动画，离开视口 200ms 后卸载与释放，显存使用稳定且不累计增长。
- 切换 Slide 验证路由卸载与跨页释放是否完整。
- 使用浏览器性能面板对 GPU 内存/纹理对象数量进行对比，确认不再增加。

## 变更影响与取舍
- 代码接入成本：为每个示例增加一次 `dispose()` 接口与 `track()` 使用；统一到封装后后续新增示例可复用。
- 用户体验：首次进入视口存在加载延迟，可通过骨架占位与轻量预加载改善。

请确认以上方案与步骤；确认后我将按“主方案：A + D 组合”落地封装与接入，逐个示例完成迁移与验证。