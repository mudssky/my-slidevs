import{o as a,c as t,k as c,e as l,ac as n,q as d,s,B as u}from"./modules/vue-DbxlR5i2.js";import{I as i}from"./slidev/default-BvtlqFyG.js";import{u as m,f as p}from"./slidev/context-B0SpK287.js";import"./index-16D_NgiB.js";import"./modules/shiki-bCin5VMP.js";const B={__name:"08Scheduler.md__slidev_44",setup(f){const{$slidev:x,$nav:S,$clicksContext:o,$clicks:_,$page:h,$renderContext:b,$frontmatter:r}=m();return o.setup(),(k,e)=>(a(),t(i,d(s(u(p)(u(r),43))),{default:c(()=>e[0]||(e[0]=[l("h3",null,"使用 Scheduler",-1),l("p",null,"即使我们没有明确声明Scheduler，实际上已经使用了Scheduler。 这是因为所有处理并发的 Observable 运算符都有可选的调度程序。如果您不提供调度程序，RxJS 将按照最小并发原则选择默认调度程序。这意味着选择引入满足操作符需求的最少并发量的调度程序。例如，对于返回具有有限且少量消息的可观察值的运算符，RxJS 不使用调度程序，即 null 或 undefined 。对于返回可能大量或无限数量消息的操作符，使用 queue 调度程序。对于使用计时器的运算符，使用 async 。",-1),l("p",null,[n("因为 RxJS 使用最少的并发调度程序，所以如果您想出于性能目的引入并发，您可以选择不同的调度程序。要指定特定的调度程序，您可以使用那些采用调度程序的运算符方法，例如 from("),l("span",null,"10, 20, 30"),n(", asyncScheduler) 。")],-1),l("p",null,"静态创建运算符通常采用调度程序作为参数。例如， from(array, scheduler) 允许您指定在传递从 array 转换的每个通知时要使用的调度程序。它通常是运算符的最后一个参数。以下静态创建运算符采用 Scheduler 参数：",-1),l("ul",null,[l("li",null,[l("code",null,"bindCallback")]),l("li",null,[l("code",null,"bindNodeCallback")]),l("li",null,[l("code",null,"combineLatest")]),l("li",null,[l("code",null,"concat")]),l("li",null,[l("code",null,"empty")]),l("li",null,[l("code",null,"from")]),l("li",null,[l("code",null,"fromPromise")]),l("li",null,[l("code",null,"interval")]),l("li",null,[l("code",null,"merge")]),l("li",null,[l("code",null,"of")]),l("li",null,[l("code",null,"range")]),l("li",null,[l("code",null,"throw")]),l("li",null,[l("code",null,"timer")])],-1)])),_:1},16))}};export{B as default};
