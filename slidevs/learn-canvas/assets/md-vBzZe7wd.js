import{_ as h}from"./CanvasBoard-B-1y74l9.js";import{d as g,t as x,L as B,o as u,c as p,B as m,k as i,e as t,ac as d,g as y,l as c,q as A,s as C}from"./modules/vue-B-ZtjMxi.js";import{u as _,f as $}from"./slidev/context-CFoHlWp9.js";import{b as D,c as T}from"./examples-G2GKnggk.js";import{_ as R}from"./slidev/VClick-BVArgB0L.js";import{I as N}from"./slidev/default-B7mrlUNe.js";import"./index-DDwREoBK.js";import"./modules/shiki-CUXul2Oe.js";import"./slidev/VClicks-CbvQnAAy.js";const S=g({__name:"Demo002ArcTo",props:{width:{default:200},height:{default:200}},setup(a){_();const o=a,n=x();return B(()=>{const r=n.value.canvasDom.getContext("2d");D(r)}),(s,r)=>{const l=h;return u(),p(l,{ref_key:"canvasBoardRef",ref:n,width:o.width,height:o.height},null,8,["width","height"])}}}),V=g({__name:"Demo002Smile",props:{width:{default:200},height:{default:150}},setup(a){_();const o=a,n=x();return(s,r)=>{const l=h;return u(),p(l,{ref_key:"canvasBoardRef",ref:n,width:o.width,height:o.height,"draw-fn":m(T)},null,8,["width","height","draw-fn"])}}}),F={__name:"01shape.md__slidev_12",setup(a){const{$slidev:o,$nav:n,$clicksContext:s,$clicks:r,$page:l,$renderContext:b,$frontmatter:v}=_();return s.setup(),(P,e)=>{const w=V,f=R,k=S;return u(),p(N,A(C(m($)(m(v),11))),{default:i(()=>[e[0]||(e[0]=t("h3",null,"圆弧",-1)),e[1]||(e[1]=t("p",null,[t("code",null,"moveTo(x, y)"),d(" 将笔触移动到指定的坐标 x 以及 y 上，实际上不画任何东西.")],-1)),e[2]||(e[2]=t("p",null,[t("code",null,"arc(x, y, radius, startAngle, endAngle, anticlockwise)"),d(" 画一个以（x,y）为圆心的以 radius 为半径的圆弧（圆），从 startAngle 开始到 endAngle 结束，anticlockwise是可选的Boolean值，如果为 true，逆时针绘制圆弧，反之，顺时针绘制。默认是顺时针")],-1)),e[3]||(e[3]=t("p",null,[t("code",null,"arcTo(x1, y1, x2, y2, radius)"),d(" 根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。(起点和2个控制点组成圆的两条切线)")],-1)),y(" `ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise)` 椭圆绘制还是略了 "),c(f,null,{default:i(()=>[c(w,{class:"inline-block"})]),_:1}),c(f,null,{default:i(()=>[c(k,{class:"inline-block ml-10"})]),_:1})]),_:1},16)}}};export{F as default};
